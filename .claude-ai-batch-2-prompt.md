# RaceSync - Batch 2: Utility Functions (T025-T027)

## Context

You're working on **RaceSync**, a mobile app for Le Mans Ultimate race schedule tracking. The project is initialized with TypeScript strict mode, React Native 0.82.1, and all type definitions are already complete.

**What's Done:**
- ✅ Project setup (React Native + TypeScript strict mode)
- ✅ Type definitions (Race, Favorite, RaceCategory, CalendarEvent, PracticeSession, Notification)
- ✅ Directory structure (feature-based organization)
- ✅ Constants (race colors, spacing values)

**Current Branch:** `001-lmu-schedule-tracker`

**GitHub Repository:** https://github.com/[YOUR_USERNAME]/racesync

## Project Specifications

Read these specs from the GitHub repository:

1. **Constitution:** https://github.com/[YOUR_USERNAME]/racesync/blob/001-lmu-schedule-tracker/.specify/memory/constitution.md
2. **Data Model:** https://github.com/[YOUR_USERNAME]/racesync/blob/001-lmu-schedule-tracker/specs/001-lmu-schedule-tracker/data-model.md
3. **Research:** https://github.com/[YOUR_USERNAME]/racesync/blob/001-lmu-schedule-tracker/specs/001-lmu-schedule-tracker/research.md

## Your Tasks (TDD Required)

You will implement **3 utility modules** using **Test-Driven Development**:

### Task T025: dateUtils.ts
**File:** `src/shared/utils/dateUtils.ts`

**Required Functions:**
1. `isValidISOString(dateString: string): boolean` - Validate ISO 8601 format
2. `parseUTC(isoString: string): Date` - Parse ISO UTC string to Date object
3. `formatLocalTime(date: Date, format: string): string` - Format Date to local time using date-fns
4. `isRaceLive(startTime: string, durationMinutes: number): boolean` - Check if race is currently happening
5. `getCurrentDateInTimezone(timezone: string): Date` - Get current date in specific timezone

**Test File:** `src/shared/utils/__tests__/dateUtils.test.ts`

**Test Requirements:**
- ✅ Test isValidISOString with valid/invalid formats
- ✅ Test parseUTC with various ISO strings
- ✅ Test formatLocalTime with different formats ('HH:mm', 'MMM d, yyyy')
- ✅ Test isRaceLive at race start, during race, after race, before race
- ✅ Test edge cases: null, undefined, empty strings

### Task T026: timezoneUtils.ts
**File:** `src/shared/utils/timezoneUtils.ts`

**Required Functions:**
1. `getDeviceTimezone(): string` - Get device's current timezone (use Intl.DateTimeFormat)
2. `convertUTCToLocal(utcISOString: string): string` - Convert UTC ISO to local ISO string
3. `recalculateOnTimezoneChange(callback: () => void): () => void` - React to timezone changes (return cleanup function)
4. `formatInTimezone(date: Date, timezone: string, format: string): string` - Format date in specific timezone

**Test File:** `src/shared/utils/__tests__/timezoneUtils.test.ts`

**Test Requirements:**
- ✅ Test getDeviceTimezone returns valid IANA timezone
- ✅ Test convertUTCToLocal with various UTC times
- ✅ Test DST transitions (spring forward, fall back)
- ✅ Test timezone changes (mock Intl changes)
- ✅ Test edge cases and error handling

### Task T027: formatters.ts
**File:** `src/shared/utils/formatters.ts`

**Required Functions:**
1. `formatCountdown(startTime: string): string` - Format time until race starts ("2h 30m", "45m", "Starting now", "Live")
2. `formatDuration(minutes: number): string` - Format race duration ("45 min", "1h 30m", "6h")
3. `formatRaceTitle(race: Race): string` - Format race title ("Hypercar - Circuit de la Sarthe")
4. `formatTimeRange(startTime: string, durationMinutes: number): string` - Format time range ("14:30 - 15:15")

**Test File:** `src/shared/utils/__tests__/formatters.test.ts`

**Test Requirements:**
- ✅ Test formatCountdown with multiple time ranges (days, hours, minutes, live)
- ✅ Test formatDuration with various durations (15min, 45min, 1h, 6h, 24h)
- ✅ Test formatRaceTitle with different race types (daily, weekly, special)
- ✅ Test formatTimeRange with various start times and durations
- ✅ Test edge cases: negative times, zero duration, past races

## Implementation Requirements

### 1. TypeScript Strict Mode ⚠️
- **NO `any` types** - Use proper TypeScript types
- Enable all strict flags (already configured)
- Full type coverage on all functions

### 2. TDD Workflow (MANDATORY) ⚠️
**You MUST follow this exact order:**

1. **Write test file FIRST** - Create `__tests__/[module].test.ts`
2. **Write all test cases** - Cover happy path + edge cases
3. **Run tests and VERIFY they FAIL** - This proves tests are working
4. **Implement the module** - Write code to pass tests
5. **Run tests and VERIFY they PASS** - All tests green

### 3. Dependencies
- Use `date-fns` v3 for date formatting (lightweight, tree-shakeable)
- Use `date-fns-tz` for timezone operations
- Import types from existing type files: `import { Race } from '@/features/schedules/types/Race'`

### 4. Code Quality
- **File size limit:** Each file <200 lines
- **Comprehensive JSDoc comments** on every function
- **Example usage** in JSDoc for complex functions
- **Error handling:** Graceful failures with meaningful messages
- **Pure functions:** No side effects (except recalculateOnTimezoneChange)

### 5. Test Quality
- Use `@testing-library/react-native` and Jest
- Test file naming: `__tests__/[module].test.ts`
- Group tests with `describe` blocks
- Use descriptive test names: `it('should return "2h 30m" for race starting in 2.5 hours')`
- Mock `Date.now()` for time-dependent tests
- Minimum 90% code coverage

## Example Test Structure

```typescript
// src/shared/utils/__tests__/formatters.test.ts
import { formatCountdown, formatDuration, formatRaceTitle, formatTimeRange } from '../formatters';
import { Race } from '@/features/schedules/types/Race';

describe('formatters', () => {
  describe('formatCountdown', () => {
    beforeEach(() => {
      // Mock current time to ensure consistent tests
      jest.useFakeTimers();
      jest.setSystemTime(new Date('2024-03-15T12:00:00Z'));
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should return "2h 30m" for race starting in 2.5 hours', () => {
      const startTime = '2024-03-15T14:30:00Z';
      expect(formatCountdown(startTime)).toBe('2h 30m');
    });

    it('should return "45m" for race starting in 45 minutes', () => {
      const startTime = '2024-03-15T12:45:00Z';
      expect(formatCountdown(startTime)).toBe('45m');
    });

    it('should return "Starting now" for race starting within 1 minute', () => {
      const startTime = '2024-03-15T12:00:30Z';
      expect(formatCountdown(startTime)).toBe('Starting now');
    });

    it('should return "Live" for race that already started', () => {
      const startTime = '2024-03-15T11:30:00Z';
      expect(formatCountdown(startTime)).toBe('Live');
    });
  });

  describe('formatDuration', () => {
    it('should format 45 minutes as "45 min"', () => {
      expect(formatDuration(45)).toBe('45 min');
    });

    it('should format 90 minutes as "1h 30m"', () => {
      expect(formatDuration(90)).toBe('1h 30m');
    });

    it('should format 360 minutes as "6h"', () => {
      expect(formatDuration(360)).toBe('6h');
    });
  });
});
```

## Example Implementation

```typescript
// src/shared/utils/formatters.ts
import { format, differenceInMinutes } from 'date-fns';
import { Race } from '@/features/schedules/types/Race';

/**
 * Format countdown to race start time
 *
 * Returns human-readable time until race starts:
 * - "2h 30m" for races >1 hour away
 * - "45m" for races <1 hour away
 * - "Starting now" for races starting within 1 minute
 * - "Live" for races that already started
 *
 * @param startTime - ISO 8601 UTC string of race start time
 * @returns Formatted countdown string
 *
 * @example
 * formatCountdown('2024-03-15T14:30:00Z') // "2h 30m"
 * formatCountdown('2024-03-15T12:45:00Z') // "45m"
 */
export function formatCountdown(startTime: string): string {
  const now = new Date();
  const start = new Date(startTime);
  const minutesUntilStart = differenceInMinutes(start, now);

  if (minutesUntilStart < 0) {
    return 'Live';
  }

  if (minutesUntilStart < 1) {
    return 'Starting now';
  }

  if (minutesUntilStart < 60) {
    return `${minutesUntilStart}m`;
  }

  const hours = Math.floor(minutesUntilStart / 60);
  const minutes = minutesUntilStart % 60;

  if (minutes === 0) {
    return `${hours}h`;
  }

  return `${hours}h ${minutes}m`;
}

// ... implement other functions
```

## Deliverables

Create **6 files total**:

1. `src/shared/utils/__tests__/dateUtils.test.ts` (comprehensive tests)
2. `src/shared/utils/dateUtils.ts` (implementation)
3. `src/shared/utils/__tests__/timezoneUtils.test.ts` (comprehensive tests)
4. `src/shared/utils/timezoneUtils.ts` (implementation)
5. `src/shared/utils/__tests__/formatters.test.ts` (comprehensive tests)
6. `src/shared/utils/formatters.ts` (implementation)

## Success Criteria

- ✅ All tests written BEFORE implementation
- ✅ All tests pass (`npm test`)
- ✅ TypeScript compiles with no errors (`npx tsc --noEmit`)
- ✅ 90%+ code coverage
- ✅ All functions have JSDoc comments
- ✅ No `any` types used
- ✅ All files <200 lines
- ✅ Code follows Prettier formatting (100 char line width)

## Notes

- **date-fns imports:** Use tree-shakeable imports: `import { format, parseISO } from 'date-fns'`
- **Timezone library:** You may need to install `date-fns-tz` for timezone utilities
- **Race type import:** `import { Race } from '../../features/schedules/types/Race'` (adjust path as needed)
- **Test mocking:** Use `jest.useFakeTimers()` and `jest.setSystemTime()` for time-dependent tests
- **Error messages:** Throw descriptive errors: `throw new Error('Invalid ISO 8601 date string')`

## Ready to Start?

Follow TDD:
1. Start with `formatters.test.ts` (easiest to test)
2. Then `formatters.ts` implementation
3. Then `dateUtils.test.ts`
4. Then `dateUtils.ts` implementation
5. Finally `timezoneUtils.test.ts` and `timezoneUtils.ts`

Run tests after each implementation to ensure they pass!

---

**After completion**, provide:
1. All 6 files with complete code
2. Test results showing all tests pass
3. TypeScript compilation results showing no errors
